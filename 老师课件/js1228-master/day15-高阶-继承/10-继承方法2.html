<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        // 1.1 父构造函数
        function Father(uname, age) {
            // this 指向父构造函数的对象实例
            this.uname = uname;
            this.age = age;
        }
        // 父构造函数的共有方法
        Father.prototype.money = function () {
            console.log('打工赚钱');
        }

        // 1.2 子构造函数
        function Son(uname, age, score) {
            // this 指向子构造函数的对象实例
            Father.call(this, uname, age);
            this.score = score;
        }

        // 2.1 子构造函数的原型对象指向父构造函数的一个实例
        Son.prototype = new Father();
        // 2.2 赋值就会覆盖，因此需要 constructor 指向原来的构造函数
        // Son.prototype.constructor = Son;
        // console.log(Son.prototype.constructor);

        let son = new Son('son', 22, 99);
        let father = new Father('father', 22);

        son.money();
        console.log('--------------------');
        Son.prototype.game = function (){
            console.log('我要打游戏');
        }

        son.game();
        // 只是给 Father 的一个实例对象添加了方法。
        // 不影响 Father 的其它实例对象
        father.game();
    </script>
</body>

</html>